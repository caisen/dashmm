OPEN QUESTIONS and TODO
TODO: Make the Array type work from inside HPX-5 threads also
TODO: Merge SourceRef and TargetRef. They are really just the same thing
      with different names. Call is ArrayRef?
TODO: Can we make the various expansion types define their input and output
      types, so that the users can just get it right? So LaplaceCOM might
      using input_t = double, output_t = std::complex<double>?
      NOTE: this does not clear up the issue of naming it correctly. So
      perhaps this is nothing too great. Also, it is not clear how this would
      work when the Expansion will depend on the Source/Target type, which
      depends on the Expansion type through this information.

      A MACRO for the Expansion? Not super useful.
TODO: Should we explicitly enforce the singleton nature of Evaluator?
TODO: currently it is impossible to use the same tree for different Evaluators.
      Do we want to decouple the tree?
TODO: Perhaps we want to parameterize the nodes with some user data? So
      the user can use the tree for other things as well.
TODO: Should we just make the evaluator into a functor? Instead of evaluate,
      we just overload ()?
TODO: Factor the bit in evaluate_handler() that gets the domain
TODO: In contribute for ExpansionLCO, can we change it so the user can just
      pass in the expansion?
TODO: Why is s_to_l_handler different than s_to_m_handler?
TODO: See if we can work out a better way to work with the consider list.
      All this to and from vectors is annoying.

Unknown:
 (Interface to Users)
 - dashmm.h - will just include all the user interface stuff

 (Recheck documentation)
 - This will need to happen. The documentation and the code has started to
   diverge somewhat. This means both the in-source stuff as well as the user
   guides.

 (Go back through and address the includes. I likely have not done this as I
  went through this.)

 (Reorganize the directory)
    Should we take the hint from HPX and reorganize things so that the includes
    are obviously from DASHMM. So instead of include/file.h it would be
    dashmm/file.h? Probably.

    We would just rename include to dashmm - no include would have a dashmm
      subdirectory, as well as a builtin/ directory for the built in stuff
    We could then have a lib folder with the built library
    We could leave src alone

    DO THIS AFTER IT IS WORKING

 (Do we do a minor release on the template stuff?)


So the basic parameters are the source type, the target type, the expansion
type and the method type.



Some notes about issues or future features

* In the future, we may want to have the ObjectHandle be something a little
more specific. Perhaps a dashmm::Array object. Of course, like everything else
it is backed by data in the GAS, but it would at least add some meaning to the
symbols in the code.

* We will need to improve the error handling in this thing quite a bit.
Basically any way that the user-facing methods can go wrong should return
sensible error where possible instead of just being assertions that fail.

* We really ought to hide all the internal interface stuff that has to be
exposed in header files separate from the users.


Interface Ideas

 * For the array get and put, should we perhaps have a template function that
   accepts iterators here? This would make it work nicely with the STL

 * Do we want to define instead SourceSpec and TargetSpec to combine the
   relevant arguments for evaluate()?

 * Is there a sensible way to templatize allocate_array?

 * Eventually the expansion should have a method indicating the number of
   charges. And the number of outputs (phi, ax, ay, az, whatever)

 * We should add a routine to check compatibility without having to call
   evaluate to check method,expansion compatibility.

 * Provide C bindings before too long

 * We should also in the near term get a base nearest neighbor search. This will
 be essential for SPH and Phil's MFV methods.
  This would be useful in much wider contexts, however.



HOW TO ADD A NEW BUILT-IN METHOD

1. Pick a name for it and create files include/****.h and src/****.cc

2. Create the ID symbol in include/ids.h and choose a unique value for that id

3. Implement the new method (.h .cc)

4. Add factory method in include/builtins.h and implement the factory in
   src/builtins.cc

5. Implement the creation action for that method in src/builtins.cc

6. Add a line to register_built_in_methods() registering the method with
   DASHMM

7. Test the new method until you are satisfied it works.
