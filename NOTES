NOTES for making this into a templatized thing:

Some things will not need any change:
 - index.h is fine
 - point.h/.cc is fine
 - types.h is fine
 - reductionops.h/.cc is also fine
 - domaingeometry.h/.cc is fine

Some things are no longer needed:
 - ids.h is now not needed

Unknown:
 (Array stuff for Users)
 - array.h/.cc
      I think this becomes templatized, but the actions do not need to be
      changed really. Perhaps these even become objects. So the user gets
      an array<Source> instead of calling allocate_array and getting an
      object handle. The resulting type is the handle.  The question is if there
      is some benefit for the actions to know the underlying type.

      Perhaps what is happening is that we really do have one large dashmm
      object. And it also defines the array types for us.  Then, init can
      happen at the end of the constructor, and fini can happen at the
      destruction of the object. Of course, multiple dashmm instances would
      then compete to be the initializer and finalizer. So these might need to
      be instead user controlled things. That way multiple instances can be
      created and there is no hpx_init problem.

      I think this will be the model. One large object called dashmm. That will
      contain the user interface for everything. The question is, how to we
      keep it from becoming this huge damn file.

 (Method related)
      The complication with this is that the specific methods need to use the
      ExpansionReferences as well as the Source and Target Nodes. So creating
      a Method means creating a template class that uses these things? This
      will take a bit of thinking. Basically Method will be templatized over
      the Expansion, the Source, and the Target types. But since there are not
      any actions required, it should just be fine to make it a typical sort
      of template.

      It also will use SourceRef and TargetRef. But those again have the
      Source, Target, Expansion as their parameters.

      Next question, how do we make the definitions available to the Method?
      This one is hard, I think.

      So the issue is that the dashmm object will be parameterized by the
      method, and the method needs something from the dashmm type to work.
      So do we somehow create multiple objects, and the dashmm object takes
      charge of creating one so that the stuff gets registered? Can I do an
      example of this to see how to make it work? A class that has two
      type arguments, one of which needs the other in the implementation?

      This is maybe okay. The dashmm object takes the four parameters, and
      defines some auxiliary classes from those. And the Method is defined by
      the user, also taking some parameters, and it needs the SourceRef and
      TargetRef, but these can also be passed as a template template parameter.
      Another option is to use the thing directly, but that is probably
      inelegant. So the user will need to be a bit clever about stuff, but that
      is okay. So Method will take Source Target Expansion and two template
      template parameters

      So there are a couple implementations of something like this in the case
      studies.

 - method.h/.cc
      So the overall interface for the Method is not really going to change, but
      we do not need to explicitly define it anywhere. I guess we need one that
      shows the basic structure, but it will not be included by anything. It
      will just specify the overall requirements on the Method concept.

      Registration of Methods is not longer sensible. So those can be removed
      along with the table init and fini stiff. Also, the creation function
      type as well as the create method thing can go away as the specific type
      will be known, and we can thus, just use it.

      So basically, this whole thing goes away and is replaced by a specification
      in the documentation about what will make a method conform to the Method
      concept.

      You know, I think we can rid ourselves of the release() requirement on the
      Method concept. I think we can just go ahead and use some POD in the type
      and not provide copy move operators, and leave the destructor simple.

      The question to answer, does this make for a strange imbalance with the
      Expansion concept? Probably not. They are already different, and will have
      different requirements. So why not go for it?
 - methodref.h/.cc
      Given that we are likely just going to copy the method type around, then
      there is no longer any reason for the method reference object, right? If
      we know the type, we can just copy it as needed. At worst, this will be
      a few numbers. Now, since this is a user type, HPX-5 will need to always
      use a marshalled action if this is being sent in a so on. But whatever.

      For BH, we are going to have a double to send around. For FMM, there is
      nothing, so it will be 1 byte (or a larger aligned thing). For fancier
      methods, this could be a problem, but the current implementation is
      always pulling copies anyway. So this is perhaps not a big deal.

      So this seems to be disappearing as well.
 - bh_method.h/.cc
      Hopefully very little change here. If anything, a simplification.
 - direct_method.h/.cc
      Hopefully very little change here. If anything, a simplification.
 - fmm_method.h/.cc
      Hopefully very little change here. If anything, a simplification.

 (Expansion related)
 - expansion.h/.cc
 - expansionref.h/.cc
 - laplace_com.h/.cc
 - laplace_sph.h/.cc

 (Built in methods and expansions)
 - builtins.h/.cc
      The evaluator will not need a specific object for the definition portion
      but we shall still need particular objects for the evaluation step.
      So this may not change much.

      We will be able to get rid of the registration portions of this stuff.

 (Evaluation)
 - evalutate.cc
 - node.h/.cc
 - particle.h/.cc

 (Setup and teardown of DASHMM)
 - initfini.cc
      This becomes very simple. Just wrappers around hpx_init and hpx_finalize

 (Interface to Users)
 - dashmm.h
 - basic.h


So the basic parameters are the source type, the target type, the expansion
type and the method type.



Some notes about issues or future features

* In the future, we may want to have the ObjectHandle be something a little
more specific. Perhaps a dashmm::Array object. Of course, like everything else
it is backed by data in the GAS, but it would at least add some meaning to the
symbols in the code.

* We will need to improve the error handling in this thing quite a bit.
Basically any way that the user-facing methods can go wrong should return
sensible error where possible instead of just being assertions that fail.

* We really ought to hide all the internal interface stuff that has to be
exposed in header files separate from the users.


Interface Ideas

 * For the array get and put, should we perhaps have a template function that
   accepts iterators here? This would make it work nicely with the STL

 * Do we want to define instead SourceSpec and TargetSpec to combine the
   relevant arguments for evaluate()?

 * Is there a sensible way to templatize allocate_array?

 * Eventually the expansion should have a method indicating the number of
   charges. And the number of outputs (phi, ax, ay, az, whatever)

 * We should add a routine to check compatibility without having to call
   evaluate to check method,expansion compatibility.

 * Provide C bindings before too long

 * We should also in the near term get a base nearest neighbor search. This will
 be essential for SPH and Phil's MFV methods.
  This would be useful in much wider contexts, however.



HOW TO ADD A NEW BUILT-IN METHOD

1. Pick a name for it and create files include/****.h and src/****.cc

2. Create the ID symbol in include/ids.h and choose a unique value for that id

3. Implement the new method (.h .cc)

4. Add factory method in include/builtins.h and implement the factory in
   src/builtins.cc

5. Implement the creation action for that method in src/builtins.cc

6. Add a line to register_built_in_methods() registering the method with
   DASHMM

7. Test the new method until you are satisfied it works.
