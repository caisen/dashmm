THIS BRANCH TODO
TODO: Go back over all the in-source documentation

NOTE: Big problem with the tree construction. We want to build the tree in
      one locality. And so to do that in the old style, this means we need to
      have all the particles in that locality as well. Eventually, we want to
      migrate the particle data to the locations where it is most advantageous.
      So the question is, do we assume that the data is local, or do we instead
      build the tree from distributed particle data.

      Sure, initially we are still doing this for SMP mode, but we want to
      get to where we can do distributed easily. So I want to think about this
      kind of thing along the way.


OPEN QUESTIONS and TODO
TODO: Make the Array type work from inside HPX-5 threads also
TODO: Should we explicitly enforce the singleton nature of Evaluator?
TODO: currently it is impossible to use the same tree for different Evaluators.
      Do we want to decouple the tree?
TODO: Perhaps we want to parameterize the nodes with some user data? So
      the user can use the tree for other things as well.
TODO: Factor the bit in evaluate_handler() that gets the domain
TODO: In contribute for ExpansionLCO, can we change it so the user can just
      pass in the expansion?
TODO: Why is s_to_l_handler different than s_to_m_handler?
TODO: See if we can work out a better way to work with the consider list.
      All this to and from vectors is annoying.
TODO: change the data() member of ExpansionLCO to be lco(). Or change the loc()
      member of TargerLCO to data();
TODO: Can we skip the laplace_sph_precompute thing? Or rather, put it into the
      constructor in some way?
TODO: Do we want to decouple the registration from the evaluation? Two objects?
      Some kind of template function?


 (Recheck documentation)

 (Do we do a minor release on the template stuff?)
    I lean toward yes. v0.6?



Some notes about issues or future features

* We will need to improve the error handling in this thing quite a bit.
Basically any way that the user-facing methods can go wrong should return
sensible error where possible instead of just being assertions that fail.



Interface Ideas

 * Provide C bindings before too long

 * We should also in the near term get a base nearest neighbor search. This will
 be essential for SPH and Phil's MFV methods.
  This would be useful in much wider contexts, however.



Some more expansions

 * So LaplaceCOM with softened force (ala GADGET)
 * Do one for Ewald technique for periodic BCs
 * Do one for Short range forces

Some more methods

 * Can we do something more like GADGET's BH method?
