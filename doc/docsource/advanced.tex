\chapter{Advanced Guide to DASHMM}
\label{ch:advanced}

In this chapter, the complete interface to DASHMM will be presented. This will
cover some repeat information as the previous chapter, but will provide more
details that are not relevant for the basic usage of DASHMM. In a few cases,
the coverage of a library construct is complete in the previous chapter, and
so those topics will not be repeated here.

The fundamental difference between the basic and advanced interface to
DASHMM is that the advanced interface is needed when a user is implementing
a new Expansion or Method. This will require a user to be familiar with more
of the details of how the execution is performed, and will thus require some
more details about how HPX-5 provides parallelism to DASHMM. However, the
extent to which a user will have to learn HPX-5 directly is still extremely
limited.

The arrangement of material in this chapter will parallel the arrangement in
the previous.

\section{DASHMM Concepts}
\label{sec:advconcepts}

This sections covers the conceptual framwork of both DASHMM's implementation
of general multipole methods and the parallelization of those methods with
HPX-5.

\subsection{Multipole method abstractions}

Both mathematically, and in the code. So the operations and the template
arguments.

\subsection{Parallelization abstractions}

More detail about this that is relevant for advanced use of the library.



\section{Basic types}

The following basic types are needed when implementing user-defined methods and
expansions.

\subsection{\texttt{Operation}}

DASHMM organizes the transformations between various forms of the potential
expansion into a set of operations. The \texttt{Operation} scoped enumeration
identifies the operations that DASHMM recognizes. They are: \texttt{Nop},
\texttt{StoM}, \texttt{StoL}, \texttt{MtoM}, \texttt{MtoL}, \texttt{LtoL},
\texttt{MtoT}, \texttt{LtoT}, \texttt{StoT}, \texttt{MtoI}, \texttt{ItoI}
and \texttt{ItoL}.

\subsection{\texttt{ExpansionRole}}

DASHMM creates Expansion objects in a number of roles. The role is essentially
a description of which tree in the dual tree an expansion is most closely
associated with, and whether the expansion is a primary or intermediate
expansion.  The \texttt{ExpansionRole} is an enumeration with the following
members: \texttt{kSourcePrimary}, \texttt{kSourceIntermediate},
\texttt{kTargetPrimary}, \texttt{kTargetIntermediate} and
\texttt{kNoRoleNeeded}. The latter is for situations that that require an
operation from the Expansion type, but which do not require expansion data.
The prototypical example of this is the \texttt{S->T} operation.

\subsection{\texttt{Index}}

Each node of both the source and target trees can be identified with four
integers: the level of the tree (starting with 0 for the root), and the
position of the low corner of the node in units of the node size at the given
level. The index allows DASHMM to not only perform accurate positional
comparisions, but also to provide an ordering of the nodes of the tree at a
given level.

\subsubsection{\texttt{Index::Index(int ix = 0, int iy = 0, int iz = 0, int lvl = 0)}}

Construct an Index with the given on-level position and level.

\subsubsection{\texttt{int Index::x() const}}

Return the on-level position in the x direction.

\subsubsection{\texttt{int Index::y() const}}

Return the on-level position in the y direction.

\subsubsection{\texttt{int Index::z() const}}

Return the on-level position in the z direction.

\subsubsection{\texttt{int Index::level() const}}

Return the level of the index.

\subsubsection{\texttt{Index Index::parent(int num = 1) const}}

Return the \texttt{num}-th parent of this \texttt{Index}.

\subsubsection{\texttt{Index Index::child(int which) const}}

Return the given child of this Index. \texttt{which} is a composite value
that indicates with each bit if the child is on the left or right in that
direction. For example for \texttt{which == 6}, the child is the left child
in the z-direction, and the right child in both the y and x directions.

\subsubsection{\texttt{int Index::which\_child() const}}

Return which child of its parent, this node is.

\subsubsection{\texttt{bool Index::operator==(const Index \&other) const}}

Equality operator.


\subsection{\texttt{DomainGeometry}}

To represent the computational domain of the sources and targets, DASHMM
uses the \texttt{DomainGeometry} object. This object can be used to convert
an \texttt{Index} into \texttt{Point}s for various locations in the volume
represented by that index. The domains represented by DASHMM are cubical
regions.

\subsubsection{\texttt{DomainGeometry::DomainGeometry()}}

Default construct a domain to begin at the origin, with a zero side length.

\subsubsection{\texttt{DomainGeometry::DomainGeometry(Point low, double size)}}

Construct a domain with the given low corner, and the given side length.

\subsubsection{\texttt{DomainGeometry::DomainGeometry(Point low, Point high, double f = 1.0)}}

Construct a domain from the given low and high corners. The given region need
not be cubical. The resulting object will represent the smallest cube that
contains the specified volume. Additionally, the final parameter can be used
to enlarge the resulting cube by a fixed fraction.

\subsubsection{\texttt{double DomainGeometry::size() const}}

Return the side length of the represented cubical volume.

\subsubsection{\texttt{Point DomainGeometry::low() const}}

Return the low corner of the represented volume.

\subsubsection{\texttt{Point DomainGeometry::high() const}}

Return the high corner of the represented volume.

\subsubsection{\texttt{Point DomainGeometry::center() const}}

Return the center of the represented volume.

\subsubsection{\texttt{Point DomainGeometry::low\_from\_index(Index idx) const}}

Return the low corner of the region represented by the given index.

\subsubsection{\texttt{Point DomainGeometry::high\_from\_index(Index idx) const}}

Return the high corner of the region represented by the given index.

\subsubsection{\texttt{Point DomainGeometry::center\_from\_index(Index idx) const}}

Return the center of the region represented by the given index.

\subsubsection{\texttt{double DomainGeometry::size\_from\_index(Index idx) const}}

Return the size of the region represented by the given index.



\section{Initializing DASHMM}

Initialization of DASHMM via \texttt{init()} requires providing the command
line arguments to the program. This is to provide the opportunity to HPX-5 to
detect any command line arguments that modify its behavior. A full description
of the available options can be found in the HPX-5 documentation. Here, we
shall cover those that are most relevant for programs using DASHMM.

NOTE: The material in this section should not be considered to be part of the
library's interface, and are subject to modification out of the control of
the DASHMM development team.

The following HPX-5 command line arguments are the most relevant to DASHMM:

\subsubsection{\texttt{--hpx-help}}

Display a help message giving a brief description of all available options.

\subsubsection{\texttt{--hpx-threads}}

Specify the number of scheduler threads that HPX-5 will use per rank.
Typically, one thread per core gives best results, but fewer is sometimes
useful in scalability studies.

\subsubsection{\texttt{--hpx-heapsize}}

Specify the size in bytes of the amount of global address space available to
each rank. The default is frequently too low for large problem sizes. This,
however, should not be set to take all of the system memory.



\section{Evaluation}

The \texttt{Evaluator} object has one additional feature that was not
covered in the previous chapter. In addition to the parameters outlined
in Chapter~\ref{ch:basic}, one final optional parameter is available.

Each Method has a distribution policy that specifies how the DAG nodes are
to be distributed around the available resources. To allow for these policies
to have some parameters selectable at runtime, the
\texttt{Evaluator::evaluate} method accepts a distribution policy object.
This allows for users to fine-tune the behavior of the distribution if needed.
When the final argument is not supplied, DASHMM employs a default constructed
object of the type \texttt{Method<Source, Target, Expansion>::distropolicy\_t},
where \texttt{Method, Source, Target} and \texttt{Expansion} are the template
arguments supplied to the particular instance of \texttt{Evaluator}.



\section{Array map actions}

The \texttt{ArrayMapAction} utility class supports a third template parameter
that controls the level of parallelism employed in the mapping of the work
to the records in the array. This parameter is an integer that has the
following meaning: if the argument is zero, the array will be handled in a
single chunk; if the argument is positive, the array will be handled in a number
of chunks equal to the number of HPX-5 scheduler threads times the provided
argument.

The default value of this argument is 1, so the default operation of
the map will be to split each rank's portion of the array into a number of
equally sized pieces equal to the number of scheduler threads. Unless there is
the possibility for variation in the amount of computation that the mapped
action performs per record, it is likely that the default value will be
the sufficient. If, however, the work for each record is variable, better
performance may be achieved with smaller chunks, and thus larger third arguments
to the template.

The full declaration of \texttt{ArrayMapAction} is as follows:

\begin{verbatim}
template <typename T, typename E, int factor = 1>
class ArrayMapAction;
\end{verbatim}



\section{DAG objects}

After the dual tree is constructed, DASHMM creates an explicit representation
of the DAG for the given method applied to the just constructed tree. This DAG
is used to perform a work distribution, and to act as a scaffold from which
the actual expansion data is instantiated. For users wishing to implement
their own methods, the DAG objects are the objects that will be needed. In
DASHMM, the Method builds a DAG from the dual tree. There are 4 classes that
make up the DAG system for DASHMM: \texttt{DAG}, \texttt{DAGInfo},
\texttt{DAGNode} and \texttt{DAGEdge}, which will be covered in turn.

\subsection{\texttt{DAGEdge}}

The edges connecting nodes in the DAG is described with the \texttt{DAGEdge}
type. This simple type holds a pointer to the source and target
\texttt{DAGNode} connected by the edges, the \texttt{Operation} that the edge
represents, and an integer weight that gives an estimate of the communication
cost of the edge. The weight is optionally used by the distribution policy to
aid in the decision about data placement around the system. The full definition
of \texttt{DAGEdge} is as follows:

\subsubsection{\texttt{DAGNode *DAGEdge::source}}

Source node of the edge.

\subsubsection{\texttt{DAGNode *DAGEdge::target}}

Target node of the edge.

\subsubsection{\texttt{Operation DAGEdge::op}}

Operation to perform along edge.

\subsubsection{\texttt{int DAGEdge::weight}}

Estimate of communication cost required if the edge were to span localities.


\subsection{\texttt{DAGNode}}

The nodes of the DAG are represented by the simple type \texttt{DAGNode}. It
contains the following public members:

\subsubsection{\texttt{std::vector<DAGEdge> DAGNode::out\_edges}}

The edges of the DAG that start at this node.

\subsubsection{\texttt{std::vector<DAGEdge> DAGNode::in\_edges}}

The edges of the DAG that end at this node.

\subsubsection{\texttt{Index DAGNode::idx}}

The index of the tree node to which this DAG node is associated.

\subsubsection{\texttt{int DAGNode::locality}}

The locality to which this node will be assigned by the distribution. Note
that this will most often be set by the distribution policy. To indicate that
the locality is not set, a value of \texttt{-1} should be used.

\subsubsection{\texttt{int DAGNode::color}}

A color that might be used by the distribution policy. This has meaning only
in the context of the distribution policy.

\subsubsection{\texttt{DAGNode::DAGNode(Index i)}}

Construct a DAG node. This will set the index to the given value, give the
locality a value of \texttt{-1}, and default construct the remaining members
of the node.


\subsection{\texttt{DAG}}

The \texttt{DAG} object is given to a distribution policy when computing the
localities of the nodes in the DAG. This is another simple object that contains
four containers of the nodes of the DAG. These containers separate the nodes
by their position in the DAG.

The \texttt{DAG} object has the following members:

\subsubsection{\texttt{std::vector<DAGNode *> source\_leaves}}

Nodes of the DAG that are associated with leaves of the source tree. These
nodes will have no incoming edges.

\subsubsection{\texttt{std::vector<DAGNode *> source\_nodes}}

All other DAG nodes that are associated with nodes of the source tree.

\subsubsection{\texttt{std::vector<DAGNode *> target\_leaves}}

Nodes of the DAG that are associated with leaves of the target tree. These
nodes will have no outgoing edges. In some methods, these are not associated
with the leaves of the target tree, but rather those nodes of the target
tree after which more refinement for the method would only induce
unnecessary overhead.

\subsubsection{\texttt{std::vector<DAGNode *> target\_nodes}}

All other DAG nodes that are associated with node of the target tree.



\subsection{\texttt{DAGInfo}}

The \texttt{DAGInfo} object contains all the information related to the DAG
for each node of the source and target trees. These objects will be the
primary means by which a Method interacts with the DAG.

Each \texttt{DAGInfo} object represents up to three DAG nodes: a particles
node, the normal DAG node, and an intemediate DAG node. The particles node
represents the terminal nodes of the DAG: either the information about
the sources, or the information about the targets. These DAG nodes do not
represent expansions. The normal
DAG node represents expansions with a role of \texttt{kSourcePrimary} or
\texttt{KTargetPrimary}. The intermediate node represents expansions with a
role of \texttt{kSouceIntermediate} or \texttt{kTargetIntermediate}. A
particular method might not use certain expansion roles, so a
\texttt{DAGInfo} object might not contain the normal or intermediate DAG node.
Further, not all tree nodes are leaves, and so only some \texttt{DAGInfo}
objects will have a particles node.

This object manages the concurrent modification of the DAG. However, that
management is hidden from users of this object.

The \texttt{DAGInfo} methods that a user might need to use in a Method are
covered below.

\subsubsection{\texttt{Index DAGInfo::index() const}}

Return the index of the volume represented by the DAG nodes owned by this
object.

\subsubsection{\texttt{bool DAGInfo::add\_normal()}}

Add a normal DAG node to this object. This will return \texttt{true} if this
call added the node. Otherwise, if the \texttt{DAGNode} already owns a normal
node, this call will do nothing, and return false.

\subsubsection{\texttt{bool DAGInfo::add\_interm()}}

Add an intermediate DAG node to this object. This will return \texttt{true} if
this call added the node. Otherwise, if the \texttt{DAGNode} already owns an
intermediate node, this call will do nothing, and return \texttt{false}.

\subsubsection{\texttt{bool DAGInfo::add\_parts()}}

Add a particles DAG node to this object. This will return \texttt{true} if this
call added the node. Otherwise, if the \texttt{DAGNode} already owns a particles
node, this call will do nothing, and return false.

\subsubsection{\texttt{bool DAGInfo::has\_normal() const}}

Predicate returning if this object owns a normal DAG node.

\subsubsection{\texttt{bool DAGInfo::has\_interm() const}}

Predicate returning if this object owns an intermediate DAG node.

\subsubsection{\texttt{bool DAGInfo::has\_parts() const}}

Predicate returning of this object owns a particles DAG node.

\subsubsection{\texttt{void DAGInfo::set\_normal\_locality(int loc)}}

Set the locality for the normal DAG node, if it exists, to the given
locality, \texttt{loc}.

\subsubsection{\texttt{void DAGInfo::set\_interm\_locality(int loc)}}

Set the locality for the intermediate DAG node, if it exists, to the given
locality, \texttt{loc}.

\subsubsection{\texttt{void DAGInfo::StoM(DAGInfo *source, int weight)}}

Connect the particles DAG node of \texttt{source} to the normal DAG node of
this object with an \texttt{S->M} operation, and assign the resulting edge the
given \texttt{weight}. It is an error to call this method if this object does
not own a normal DAG node, and if the \texttt{source} does not own a particles
DAG node.

\subsubsection{\texttt{void DAGInfo::StoL(DAGInfo *source, int weight)}}

Connect the particles DAG node of \texttt{source} to the normal DAG node of
this object with an \texttt{S->L} operation, and assign the resulting edge the
given \texttt{weight}. It is an error to call this method if this object does
not own a normal DAG node, and if the \texttt{source} does not own a particles
DAG node.

\subsubsection{\texttt{void DAGInfo::MtoM(DAGInfo *source, int weight)}}

Connect the normal DAG node of \texttt{source} to the normal DAG node of
this object with an \texttt{M->M} operation, and assign the resulting edge the
given \texttt{weight}. It is an error to call this method if this object does
not own a normal DAG node, and if the \texttt{source} does not own a normal
DAG node.

\subsubsection{\texttt{void DAGInfo::MtoL(DAGInfo *source, int weight)}}

Connect the normal DAG node of \texttt{source} to the normal DAG node of
this object with an \texttt{M->L} operation, and assign the resulting edge the
given \texttt{weight}. It is an error to call this method if this object does
not own a normal DAG node, and if the \texttt{source} does not own a normal
DAG node.

\subsubsection{\texttt{void DAGInfo::LtoL(DAGInfo *source, int weight)}}

Connect the normal DAG node of \texttt{source} to the normal DAG node of
this object with an \texttt{L->L} operation, and assign the resulting edge the
given \texttt{weight}. It is an error to call this method if this object does
not own a normal DAG node, and if the \texttt{source} does not own a normal
DAG node.

\subsubsection{\texttt{void DAGInfo::MtoT(DAGInfo *target, int weight)}}

Connect the normal DAG node of this object to the particles DAG node of
\texttt{source} with an \texttt{M->T} operation, and assign the resulting edge
the given \texttt{weight}. It is an error to call this method if this object
does not own a normal DAG node, and if the \texttt{source} does not own a
particles DAG node.

\subsubsection{\texttt{void DAGInfo::LtoT(DAGInfo *target, int weight)}}

Connect the normal DAG node of this object to the particles DAG node of
\texttt{source} with an \texttt{L->T} operation, and assign the resulting edge
the given \texttt{weight}. It is an error to call this method if this object
does not own a normal DAG node, and if the \texttt{source} does not own a
particles DAG node.

\subsubsection{\texttt{void DAGInfo::StoT(DAGInfo *source, int weight)}}

Connect the particles DAG node of \texttt{source} to the particles DAG node of
this object with an \texttt{S->T} operation, and assign the resulting edge the
given \texttt{weight}. It is an error to call this method if this object does
not own a particles DAG node, and if the \texttt{source} does not own a
particles DAG node.

\subsubsection{\texttt{void DAGInfo::MtoI(DAGInfo *source, int weight)}}

Connect the normal DAG node of \texttt{source} to the intermediate DAG node of
this object with an \texttt{M->I} operation, and assign the resulting edge the
given \texttt{weight}. It is an error to call this method if this object does
not own a normal DAG node, and if the \texttt{source} does not own an
intermediate DAG node.

\subsubsection{\texttt{void DAGInfo::ItoI(DAGInfo *source, int weight)}}

Connect the intermediate DAG node of \texttt{source} to the intermediate DAG
node of this object with an \texttt{I->I} operation, and assign the resulting
edge the given \texttt{weight}. It is an error to call this method if this
object does not own an intermediate DAG node, and if the \texttt{source} does
not own an intermediate DAG node.

\subsubsection{\texttt{void DAGInfo::ItoL(DAGInfo *source, int weight)}}

Connect the intermediate DAG node of \texttt{source} to the normal DAG
node of this object with an \texttt{I->L} operation, and assign the resulting
edge the given \texttt{weight}. It is an error to call this method if this
object does not own a normal DAG node, and if the \texttt{source} does
not own an intermediate DAG node.



\section{\texttt{ViewSet}}

The \texttt{ViewSet} object is a means by which a subset of the possible views
of an Expansion can be selected. The DASHMM concept of Expansion allows for
multiple mathematical expansions to be contained in the Expansion object. This
is a feature used by some advanced methods. A \texttt{ViewSet} essentially
indexes over the possible views of an Expansion. For example, if an
Expansion has six versions (or six views) of the data, then a \texttt{ViewSet}
might select a subset of these: views 2, 4 and 5. Like anything in C++, the
indices are zero based. The particular meaning of each index is defined only
with respect to the Expansion's implementation.

\subsubsection{\texttt{ViewSet::ViewSet()}}

Default construct the object.

\subsubsection{\texttt{ViewSet::ViewSet(ExpansionRole role, const Point \&center, double scale)}}

Create an empty \texttt{ViewSet}, while setting a few vital features: the
\texttt{role} of the represented expansion, the \texttt{center} around which it
is defined, and the \texttt{scale} used for scaling-variant kernels.

\subsubsection{\texttt{void ViewSet::clear()}}

Clear out the object. After clear, it will be as if the object were default
constructed.

\subsubsection{\texttt{void ViewSet::add\_view(int index)}}

Add a view with the given \texttt{index}. This is an incomplete view.

\subsubsection{\texttt{void ViewSet::add\_view(int index, size\_t bytes, char *data)}}

Add a view with the given \texttt{index}, size in \texttt{bytes} and
\texttt{data}. This is a complete view, indicating not only which index, but
also the data backing the view.

NOTE: The \texttt{ViewSet} does not assume ownership of \texttt{data}.

\subsubsection{\texttt{void ViewSet::set\_bytes(int view, size\_t bytes)}}

Set the size of a given view. \texttt{view} gives which view of this object to
set the size of. That is, \texttt{view} is not an index into the original
Expansion, but an index into the set of views represented in this object.

\subsubsection{\texttt{void ViewSet::set\_data(int view, char *data)}}

Set the data for a given view. \texttt{view} gives which view of this object to
set the size of. That is, \texttt{view} is not an index into the original
Expansion, but an index into the set of views represented in this object.

\subsubsection{\texttt{void ViewSet::set\_role(ExpansionRole role)}}

Set the \texttt{role} of this object.

\subsubsection{\texttt{void ViewSet::set\_center(const Point \&center)}}

Set the \texttt{center} of this object. This represents the point around
which the expansion is defined.

\subsubsection{\texttt{void ViewSet::set\_scale(double s)}}

Set the \texttt{scale} of this object. This is needed for scaling-variant
kernels.

\subsubsection{\texttt{int ViewSet::view\_index(int view) const}}

Return the index in the original Expansion that is represented by the
given \texttt{view}.

\subsubsection{\texttt{size\_t ViewSet::view\_bytes(int view) const}}

Return the size in bytes of the given \texttt{view}.

\subsubsection{\texttt{char *ViewSet::view\_data(int view) const}}

Return the data of the given \texttt{view}.

\subsubsection{\texttt{ExpansionRole ViewSet::role() const}}

Return the role of the represented expansion.

\subsubsection{\texttt{Point ViewSet::center() const}}

Return the center of the represented expansion.

\subsubsection{\texttt{double ViewSet::scale() const}}

Return the scale of the represented expansion.

\subsubsection{\texttt{int ViewSet::count() const}}

Return the number of views in this object.

\subsubsection{\texttt{size\_t ViewSet::bytes() const}}

Return the total size of the data represented by this object. This includes
not only the data of the views themselves, but some metadata used during
serialization of this object.


\section{Tree nodes}

The nodes of the dual tree are implemented as the class \texttt{Node<T>}, which
is a template over the record type, either Source or Target. Typically these
types are aliased to \texttt{sourcenode\_t = Node<Source>}, and
\texttt{targetnode\_t = node<Target>}. The members of this class that might be
needed by implementers of new Methods are detailed below.

\subsubsection{\texttt{Index Node<T>::idx}}

The index of the tree node.

\subsubsection{\texttt{Node<T> *Node<T>::parent}}

The parent of this node in the tree. This is only \texttt{nullptr} if this is
the root.

\subsubsection{\texttt{Node<T> *Node<T>::child[8]}}

The children of this node in the tree. These might be \texttt{nullptr}.

\subsubsection{\texttt{DAGInfo Node<T>::dag}}

A \texttt{DAGInfo} object providing a handle to the relevant portions of the
DAG for this node.

\subsubsection{\texttt{bool Node<T>::is\_leaf() const}}

A utility predicate answering the question: Is this node a leaf?


\section{Built-in distribution policies}

The distribution policy controls on which localities the nodes of the DAG
are ultimately placed. Each Method is required to define a distribution policy
to be used with that method (see below). DASHMM has a few built-in distribution
policies that can be used in user-defined methods. Additionally, there is a
default policy defined that represents the current best all-around policy
available in DASHMM. To make use of this default in a user-defined Method,
one merely has to include the following in the class definition:

\begin{verbatim}
using distropolicy_t = dashmm::DefaultDistributionPolicy;
\end{verbatim}

\noindent \texttt{DefaultDistributionPolicy} is defined in
\texttt{dashmm/defaultpolicy.h}.

Each distribution policy only sets the locality of nodes that are not
automatically set by DASHMM. DAG nodes that have an automatically determined
locality include: the source DAG nodes, the target DAG nodes, and those
normal expansions on the source or target side representing the same node of
the source or target tree as a source or target DAG node.

The following distribution policies are included with DASHMM:

\subsubsection{\texttt{SingleLocality}}

This distribution policy places all of the DAG nodes on a single locality in
the system. The locality can be selected in the constructor, and has a default
value of 0: \texttt{SingleLocality::SingleLocality(int loc = 0)}.

\subsubsection{\texttt{RandomDistro}}

This distribution places DAG nodes around the available localities at random.
Note that this is generally speaking a bad idea, but the scaling of this
distribution is not bad, even if the raw performance is bad. The seed for the
RNG can be set using the constructor, which has a default value:
\texttt{RandomDistro::RandomDistro(int seed = 137)}.

\subsubsection{\texttt{BHDistro}}

This distribution policy, which is the policy used for the \texttt{BH} method,
is compatible with any method; there is no dependence on its operation on the
sorts of DAG nodes or the operations perfomed on the DAG edges. This policy
works by starting at the target DAG nodes and working backwards through the
rest of the DAG. The locality of a node being examined is set to the locality
which minimizes the communication with other localities. In deciding what is
the minimal communication, the weight of the DAG edges is used to approximate
the cost of the message.

\subsubsection{\texttt{FMM97Distro}}

TODO: Have Bo write this section...



\section{User-defined Expansions}

To define an expansion, a user need only create a class that conforms to the
following interface. For more details on the relation of Expansions to the
mathematics, please see section~\ref{sec:advconcepts} above. To implement a
user-defined Expansion, one must be familiar with the following DASHMM
constructs: \texttt{Point}, \texttt{ExpansionRole}, \texttt{ViewSet},
\texttt{Index}, \texttt{Operation} and \texttt{dcomplex\_t}.

In the following, we shall take the name of the user-defined Expansion to
be \texttt{Expansion}, but one can use any other name that one wishes.

Expansions are template types with two parameters, the Source and Target
types. The following would be the declaration of the user-defined Expansion:

\begin{verbatim}
template <typename Source, typename Target>
class Expansion;
\end{verbatim}

\noindent It is not required, but the following aliases will be assumed to be
have been defined in the following description of the Expansion interface:

\begin{verbatim}
using source_t = Source;
using target_t = Target;
using expansion_t = Expansion<Source, Target>;
\end{verbatim}

\noindent The latter introduces some brevity, while the former are mostly
for completeness, though in some situations involving the \texttt{auto} keyword
they allow for retrieving the Source and Target type.

\subsubsection{\texttt{Expansion::Expansion(Point center, double scale, ExpansionRole role)}}

This constructor creates the expansion object with the given \texttt{center},
\texttt{scale} and \texttt{role}. There is no obligation on the part of the
expansion to use these inputs, but they will be provided for those expansions
that will need these data.

The scale provided to this constructor will be produced by
\texttt{Expansion::compute\_scale}.

\subsubsection{\texttt{Expansion::Expansion(const ViewSet \&views)}}

This constructor interprets the provided \texttt{views} as the data serving
this expansion. Unlike the previous constructor, this constructor produces an
object that does not own any data. Instead, it interprets existing data.

Further, this constructor must be able to operate in a mode where \texttt{views}
is empty. This `shallow` mode of construction is for cases where the
expansion data is not needed, such as the \texttt{S->T} operation, but where
some of the kernel parameters might be needed.

\subsubsection{\texttt{Expansion::~Expansion()}}

The destructor should free the data of the expansion. In some instances, the
expansion will not own any data, and so this should do nothing. Only if the
expansion is \texttt{valid()} should this ever delete allocated memory.

\subsubsection{\texttt{void Expansion::release()}}

This will release the internal data for an expansion. These objects need to
support the ability to export the data making the expansion, losing ownership
of the data in the process. Further, expansion objects need to be able to be
constructed in a shallow way from existing data. \texttt{release()} breaks the
association. After \texttt{release()}, calls to \texttt{valid()} must return
false.

The simplest implementation of this is to have the object store a pointer to
memory allocated on the heap (as in \texttt{new char [size]}), and
\texttt{release()} can just set that pointer to \texttt{nullptr}.

\subsubsection{\texttt{bool Expansion::valid(const ViewSet \&views) const}}

Returns if the indicated views are valid. An expansion is valid if it has
data associated with it. If \texttt{views} is empty, this will check all
views.

\subsubsection{\texttt{int Expansion::view\_count() const}}

Return the current number of views for this object. This will either be the
full number for an object created with the first constructor, or a smaller
number for an expansion created by interpretation in the second constructor.

\subsubsection{\texttt{void Expansion::get\_views(ViewSet \&views) const}}

Fill in data in the \texttt{views} object. Given a \texttt{ViewSet} that
contains the view indicies, this will populate the size and data members of
\texttt{views}. Note that this does not perform a copy of the data in the
views.

\subsubsection{\texttt{ViewSet Expansion::get\_all\_views() const}}

Get all current views of this object.

\subsubsection{\texttt{ExpansionRole Expansion::role() const}}

Return the expansion role of this object.

\subsubsection{\texttt{Point Expansion::center() const}}

Return the point around which the expansion is defined.

\subsubsection{\texttt{size\_t Expansion::view\_size(int view) const}}

Return the view size for the specified \texttt{view}. This returns the number
of terms in the expansion for the given view. Do not confuse this with the
size in bytes of the data in a given view, which can be obtained with
\texttt{get\_views()}.

\subsubsection{\texttt{dcomplex\_t Expansion::view\_term(int view, size\_t i) const}}

Get term \texttt{i} of the given \texttt{view}. The term is returned as a
complex number, so real-valued expansions must return a complex number.

\subsubsection{\texttt{std::unique\_ptr<expansion\_t> Expansion::S\_to\_M(Point center, source\_t *first, source\_t *last) const}}

Create a multipole expansion for a given set of sources. The expansion will
have the given \texttt{center}, and the sources are gives as pointers to the
\texttt{first} and one past the \texttt{last} record.

The returned expansion will have a role of \texttt{kSourcePrimary}.

\subsubsection{\texttt{std::unique\_ptr<expansion\_t> Expansion::S\_to\_L(Point center, source\_t *first, source\_t *last) const}}

Create a local expansion for a given set of sources. The expansion will
have the given \texttt{center}, and the sources are gives as pointers to the
\texttt{first} and one past the \texttt{last} record.

The returned expansion will have a role of \texttt{kTargetPrimary}.

\subsubsection{\texttt{std::unique\_ptr<expansion\_t> Expansion::M\_to\_M(int from\_child, double s\_size) const}}

Change the center of a multipole expansion. The shift in the center is
specified through \texttt{from\_child}, which indicates the child from which
the expansion is being converted. \texttt{s\_size} is the size of that child
node.

This expansion will have a role of \texttt{kSourcePrimary}.

The returned expansion will have a role of \texttt{kSourcePrimary}.


\subsubsection{\texttt{std::unique\_ptr<expansion\_t> Expansion::M\_to\_L(Index s\_index, double s\_size, Index t\_index) const}}

Convert a multipole expansion to a local expansion. To specify the change the
source and target indices (\texttt{s\_index} and \texttt{t\_index}), as well
as the size of the source (\texttt{s\_size}) are provided.

This expansion will have a role of \texttt{kSourcePrimary}.

The returned expansion will have a role of \texttt{kTargetPrimary}.

\subsubsection{\texttt{std::unique\_ptr<expansion\_t> Expansion::L\_to\_L(int to\_child, double t\_size) const}}

Convert a local expansion to a local expansion for a child. The child is
specified by \texttt{to\_child}, which gives the child of the tree node
associated with this expansion that the resulting expansion should be
associated with.

This expansion will have a role of \texttt{kTargetPrimary}.

The returned expansion will have a role of \texttt{kTargetPrimary}.

\subsubsection{\texttt{void Expansion::M\_to\_T(target\_t *first, target\_t *last) const}}

Apply the effect of a multipole expansion to a set of targets, specified by
a pointer to the \texttt{first} and one past the \texttt{last} target.

This expansion will have a role of \texttt{kSourcePrimary}.

\subsubsection{\texttt{void Expansion::L\_to\_T(target\_t *first, target\_t *last) const}}

Apply the effect of a local expansion to a set of targets, specified by
a pointer to the \texttt{first} and one past the \texttt{last} target.

This expansion will have a role of \texttt{kTargetPrimary}.

\subsubsection{\texttt{void Expansion::S\_to\_T(source\_t *s\_first, source\_t *s\_last, target\_t *t\_first, target\_t *t\_last) const}}

Apply the direct interaction of a set of sources to a set of targets. The
sources and targets are specified by pointers to the first and one past the
last record.

\subsubsection{\texttt{std::unique\_ptr<expansion\_t> Expansion::M\_to\_I(Index s\_index) const}}

Create an intermediate expansion from a multipole expansion. \texttt{s\_index}
is the index of the tree node being represented by both the multipole and
intermediate expansions.

This expansion will have a role of \texttt{kSourcePrimary}.

The returned expansion will have a role of \texttt{kSourceIntermediate}.

\subsubsection{\texttt{std::unique\_ptr<expansion\_t> Expansion::I\_to\_I(Index s\_index, double s\_size, Index t\_index) const}}

Translate a source-side intermediate expansion into a target-side intermediate
expansion. The \texttt{s\_index} and \texttt{t\_index} are the index of the
tree nodes that are represented by this object, and the resulting expansion,
respectively. Additionally, the \texttt{s\_size} gives the size of the source
tree node.

This expansion will have a role of \texttt{kSourceIntermediate}.

The returned expansion will have a role of \texttt{kSourceIntermediate}.

\subsubsection{\texttt{std::unique\_ptr<expansion\_t> Expansion::I\_to\_L(Index t\_index, double t\_size) const}}

Translate a target-side intermediate expansion into a local expansion. The
target tree node's index, \texttt{t\_index}, and size, \texttt{t\_size},
are provided.

This expansion will have a role of \texttt{kTargetIntermediate}.

The returned expansion will have a role of \texttt{kTargetPrimary}.

\subsubsection{\texttt{void Expansion::add\_expansion(const expansion\_t *temp}}

Add the given expansion to this expansion. Typically this involves summing the
coefficients, but can be more involved in some cases.

\subsubsection{\texttt{static void Expansion::update\_table(int n\_digits, double domain\_size, const std::vector<double> \&kernel\_params)}}

Update a kernel table. This should generate or update a kernel table associated
with this expansion type. The kernel table is a mechanism for precomputing
values that are required by expansion operations. As the same table should
serve every instance of this class, the table should be a static member of the
class. This routine will either allocate and fill these tables (if this is the
first call to this function during the program lifetime, or if the table has
been explicitly deleted) or it will replace the values in the table without
necessarily reallocating the memory for the table (if this is a subsequent call
to this function).

The value of \texttt{n\_digits} and \texttt{kernel\_params} are ultimately
provided by the user's call to \texttt{Evaluator::evaluate()}. The
\texttt{domain\_size} is computed by DASHMM after the tree is constructed.

\subsubsection{\texttt{static void Expansion::delete\_table()}}

Destroy the kernel table. This should destroy any tables that exist that are
associated with this type of expansion.

\subsubsection{\texttt{static double Expansion::compute\_scale(Index index)}}

Compute the scale to pass into expansion constructors. The will only be called
after the table exists, so the implementation can rely on the existence of the
table. In particular, kernel parameters needed by this routine should be
stored in the table.

\subsubsection{\texttt{static int Expansion::weight\_estimate(Operation op, Index s = Index\{\}, Index t = Index\{\})}}

Compute an estimate of the cost to send the result of the given operation
across the network. In some expansions, the operation is enough to determing
the cost. In others, the source and target indices, \texttt{s} and \texttt{t}.



\section{User-defined Methods}

To create a user-defined Method, one must create a class with that conforms
to the following interface. For a description of the four primary routines
of a Method, please see~\ref{sec:advconcepts}. To implement a user-defined
Method, one must be familiar with the following DASHMM constructs: the
\texttt{Expansion} concept, nodes of the tree (both souce and target),
\texttt{DomainGeometry} and \texttt{DAGInfo}.

In the following we shall take the name of the user-defined Method to be
\texttt{Method}, but one can use any name that one wishes.

Methods are templates over three parameters, the Source, Target and Expansion
types. The following is the full declaration of a user-defined Method:

\begin{verbatim}
template <typename Source, typename Target,
          template <typename, typename> class Expansion>
class Method;
\end{verbatim}

\noindent It is helpful to also define the following aliases as members of
any Method:

\begin{verbatim}
using source_t = Source;
using target_t = Target;
using expansion_t = Expansion<Source, Target>;
using method_t = Method<Source, Target, Expansion>;
using sourcenode_t = Node<Source>;
using targetnode_t = Node<Target>;
\end{verbatim}

\noindent The above aliases will be used in the following description.

\subsubsection{\texttt{Method::distropolicy\_t}}

Any method must define this type to specify the distribution policy that is to
be used with the method. This allows for the possibility that special details
of the implemented \texttt{Method} might allow for better distribution of the
DAG. If there is no such better distribution, or the implementer is not
concerned, or if the default provided by DASHMM is found to be sufficient, then
one can use \texttt{dashmm::DefaultDistributionPolicy} defined in
\texttt{dashmm/defaultpolicy.h}.

\subsubsection{\texttt{Method::Method()}}

Methods must have a default constructor. Note that other constructors are
allowed. Methods instances used for particular evaluations are copied so
methods can support runtime parameters.

\subsubsection{\texttt{void Method::generate(sourcenode\_t *curr, DomainGeometry *domain) const}}

This routine is called at the leaves of the source tree to generate the initial
expansions from the source data. The leaf node in question is provided via
\texttt{curr}. For use in cases where the size of the node is relevant,
the problem \texttt{domain} is also provided. The typical interaction with
\texttt{curr} is to use its \texttt{dag} member.

\texttt{generate} is responsible for creating the DAG nodes that the method
requires for the given source tree leaf node. Further, any operations between
these nodes should be scheduled during \texttt{generate} (via the many
\texttt{DAGInfo} methods). The typical operation scheduled during
\texttt{generate} is \texttt{S->M}.


\subsubsection{\texttt{void Method::aggregate(sourcenode\_t *curr, DomainGeometry *domain) const}}

This routine is called for the internal nodes of the source tree to generate
any expansions needed by the method that are associated with non-leaf source
tree nodes. The current node, \texttt{curr}, and the overall \texttt{domain}
are provided.

\texttt{aggregate} is responsible for creating the DAG nodes that the method
requires. Further, operations between nodes should be scheduled. The typical
operation for \texttt{aggregate} is \texttt{M->M}.

\subsubsection{\texttt{void Method::inherit(targetnode\_t *curr, DomainGeometry *domain, bool curr\_is\_leaf) const}}

In \texttt{inherit} information from parents in the target tree are propagated
to children. In addition to the node, \texttt{curr} and the \texttt{domain},
whether is the current node is a leaf if indicated with
\texttt{curr\_is\_leaf}. This is necessary as some methods might allow for
internal target tree nodes to nonetheless act as if they were leaves.

\texttt{inherit} is responsible for creating the DAG nodes that the method
requires, and for scheduling the operations between DAG nodes. The typical
operation for \texttt{inherit} is \texttt{L->L}.

\subsubsection{\texttt{void Method::process(targetnode\_t *curr, std::vector<sourcenode\_t *> \&consider, bool curr\_is\_leaf, DomainGeometry *domain) const}}

The most complex work of the method often takes place in \texttt{process}. In
addition to the current node, the domain geometry, and if this leaf is a node,
a vector of source tree nodes are provided. This vector, \texttt{consider},
gives the list of source nodes that might have an impact on the calculation of
the potential for the target locations represented by this node.

\texttt{consider} should be examined, and where possible elements should be
removed from the vector when their effect on the targets in \texttt{curr} can
be computed. That is, if some opaeration is scheduled between a node in
\texttt{consider} and \texttt{curr}, then that source node has been handled,
and can be removed. In some instances, a node might be removed from
\texttt{consider} and the children of that node will be added to consider.

At the end of \texttt{process}, the set of nodes in \texttt{consider} will be
different than were passed into this function. The resulting \texttt{consider}
will be passed to the children of \texttt{curr}, unless \texttt{curr\_is\_leaf}
was true. In that case, it should be that \texttt{consider} will have been
completely used by the call to \texttt{process}.

\subsubsection{\texttt{void Method::refine\_test(bool same\_sources\_and\_targets, const targetnode\_t *curr, const std::vector<sourcenode\_t *> \&consider) const}}

This method determines if the given target tree node should be refined, or if
it represents a leaf of the DAG. This decision is based on \texttt{curr},
\texttt{consider} and if the sources and targets are identical in this
evaluation. The latter is provided as \texttt{same\_sources\_and\_targets}.

This method should return \texttt{true} if the target tree should be refined
further, and \texttt{false} otherwise.



\section{User-defined distribution policies}

For users defining their own Methods, it can potentially be helpful to also
define a distribution policy for that method if the built-in methods cannot
take advantage of details of the generated DAG. This section outlines the
concept of \texttt{DistributionPolicy}, giving details on the required
interface. Distribution policies have a relatively small interface. For the
sake of discussion, we shall call the user-defined policy \texttt{Policy},
but one can give any name to the policy.

\subsubsection{\texttt{Policy::Policy()}}

Distribution policies require either a default constructor, or a constructor
with all arguments given default values.

\subsubsection{\texttt{void Policy::compute\_distribution(DAG \&dag)}}

This is the main distribution method. After the DAG is fully discovered, it will
be passed into this function where the localities of every DAG node need to be
given a value. Because DASHMM sets a few localities in a fixed way, only those
DAG nodes with a locality set to \texttt{-1} (the default value) should have
a locality assigned. Changing the locality of a DAG node that has already had
a locality assigned will lead to program failure and termination.

Other than the previous two conditions, there are no other restriction on the
implementation. However, it is generally best to avoid very deep recursion.
HPX-5 threads each have a stack associated with them, and these stacks are
generally small, given that there will be a large number of threads. Thus, it
is much easier to overrun a thread's stack.

\subsubsection{\texttt{void Policy::assign\_for\_source(DAGInfo \&dag, int locality)}}

The routine is called for every source tree node during DAG discovery. It is an
opportunity to set localities when the DAG nodes are created, and not all at
once in \texttt{compute\_distribution}.

WARNING: There is inadequate contention management available to safely use this
routine without a thorough understanding of the internal workings of DASHMM.
It is strongly advised to not give this method a non-trivial implementation.

NOTE: This is an experimental feature, and should not be considered to be part
of the DASHMM API; it may be removed in the future.

\subsubsection{\texttt{void Policy::assign\_for\_target(DAGInfo \&dag, int locality)}}

The routine is called for every target tree node during DAG discovery. It is an
opportunity to set localities when the DAG nodes are created, and not all at
once in \texttt{compute\_distribution}.

WARNING: There is inadequate contention management available to safely use this
routine without a thorough understanding of the internal workings of DASHMM.
It is strongly advised to not give this method a non-trivial implementation.

NOTE: This is an experimental feature, and should not be considered to be part
of the DASHMM API; it may be remove in the future.
