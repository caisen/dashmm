//NOTES:
	HPX_REGISTER_ACTION(HPX_DEFAULT, HPX_ATTR_NONE, 
			create_tree_, create_tree_handler, 
			HPX_POINTER, HPX_POINTER, HPX_INT);
	HPX_REGISTER_ACTION(HPX_DEFAULT, HPX_ATTR_NONE,
                        create_DAG_, create_DAG_handler,
                        HPX_POINTER, HPX_POINTER, HPX_POINTER);
	HPX_REGISTER_ACTION(HPX_DEFAULT, HPX_ATTR_NONE,
                        create_table_, create_table_handler,
                        HPX_INT, HPX_POINTER); //TYPE OF kernelparams?
	HPX_REGISTER_ACTION(HPX_DEFAULT, HPX_ATTR_NONE,
                        do_eval_, do_eval_handler,
                        HPX_POINTER);
	HPX_REGISTER_ACTION(HPX_DEFAULT, HPX_ATTR_NONE,
                        clear_DAG_, clear_DAG_handler,
                        HPX_POINTER);
	HPX_REGISTER_ACTION(HPX_DEFAULT, HPX_ATTR_NONE,
                        clear_tree_, clear_tree_handler,
                        HPX_POINTER);

//

RankWise<dualtree_t> create_tree(const Array<source_t> &sources, const Array<source_t> &targets, 										 int &refinement_limit){
		RankWise<dualtree_t> tree;
		size_t n_params = kernelparams.size();
		size_t total_size = sizeof(EvaluateParams) + n_params * sizeof(double);
		EvaluateParams *args =
		    reinterpret_cast<EvaluateParams *>(new char[total_size]); //CONSIDER CHANGING
		args->sources = sources;
		args->targets = targets;
		args->refinement_limit = refinement_limit;
		args->method = method;
		args->n_digits = n_digits;
		args->distro = distro;
		args->rwaddr = HPX_NULL;
		args->alldone = HPX_NULL;
		args->middone = HPX_NULL;

		int e = hpx_run(&create_tree_, &tree, &sources, &targets, &refinement_limit);
		return tree;
	}

	int create_table(int &n_digit, const std::vector<double> &kernelparams){
		int e = hpx_run(&create_table_, NULL, &n_digit, &kernelparams);
		return e;
	}

	int create_DAG(RankWise<dualtree_t> &tree, const method_t &method, const distropolicy_t &distro){
		DAG dag;		
		int e = hpx_run(&create_DAG_, &dag, &tree, &method, &distro);
		return dag;
	}

	int do_eval(DAG &dag){
		int e = hpx_run(&do_eval_, NULL, &dag);
		return e;
	}

	int clear_DAG(DAG &dag){
		int e = hpx_run(&clear_DAG_, NULL, &dag);
		return e;
	}

	int clear_tree(RankWise<dualtree_t> &tree){
		int e = hpx_run(&clear_tree_, NULL, &tree);
		return e;
	}

//The actions for repeated evaluation
  static hpx_action_t create_tree_;
  static hpx_action_t create_DAG_;
  static hpx_action_t create_table_;
  static hpx_action_t do_eval_;
  static hpx_action_t clear_DAG_;
  static hpx_action_t clear_tree_; 

//HANDLES FOR ITERATIVE

  static int create_tree_handler(const Array<source_t> &sources, const Array<source_t> &targets, 									 int &refinement_limit){
	// BEGIN TREE CREATION
    hpx_time_t creation_begin = hpx_time_now();
    RankWise<dualtree_t> global_tree =
        dualtree_t::create(refinement_limit, sources,
                           targets);
    hpx_addr_t partitiondone =
        dualtree_t::partition(global_tree, sources, targets);
    hpx_lco_wait(partitiondone);
    hpx_lco_delete_sync(partitiondone);
    hpx_time_t creation_end = hpx_time_now();
    double creation_deltat = hpx_time_diff_us(creation_begin, creation_end);
    fprintf(stdout, "Evaluation: tree creation %lg [us]\n", creation_deltat);
    // END TREE CREATION

	hpx_exit(sizeof(RankWise<dualtree_t>), &global_tree);
  }
  
  static int create_table_handler(){
	// Save tree global address in message
    hpx_addr_t rwaddr = global_tree.data();
    // Save alldone LCO into message
    hpx_addr_t alldone = hpx_lco_and_new(hpx_get_num_ranks());
    assert(alldone != HPX_NULL);
    // The third is the expansion creation done LCO
    hpx_addr_t middone = hpx_lco_and_new(hpx_get_num_ranks());
    assert(middone != HPX_NULL);
  }

  static int create_DAG_handler(){
	
  }

  static int do_eval_handler(){}
  static int clear_DAG_handler(){}
  static int clear_tree_handler(){}
  
  static int create_table_rank_local_handler(){
	// Generate the table
    RankWise<dualtree_t> global_tree{parms->rwaddr};
    auto tree = global_tree.here();
    double domain_size = tree->domain()->size();
    size_t n_params = (msg_size - sizeof(EvaluateParams)) / sizeof(double);
    std::vector<double> kernel_params(parms->kernelparams,
                                      &parms->kernelparams[n_params]);
    expansion_t::update_table(parms->n_digits, domain_size, kernel_params);
    tree->set_method(parms->method);

  }


template <typename S, typename T,
          template <typename, typename> class E,
          template <typename, typename,
                    template <typename, typename> class> class M>
hpx_action_t Evaluator<S, T, E, M>::create_tree_ = HPX_ACTION_NULL;

template <typename S, typename T,
          template <typename, typename> class E,
          template <typename, typename,
                    template <typename, typename> class> class M>
hpx_action_t Evaluator<S, T, E, M>::create_DAG_ = HPX_ACTION_NULL;

template <typename S, typename T,
          template <typename, typename> class E,
          template <typename, typename,
                    template <typename, typename> class> class M>
hpx_action_t Evaluator<S, T, E, M>::create_table_ = HPX_ACTION_NULL;

template <typename S, typename T,
          template <typename, typename> class E,
          template <typename, typename,
                    template <typename, typename> class> class M>
hpx_action_t Evaluator<S, T, E, M>::do_eval_ = HPX_ACTION_NULL;

template <typename S, typename T,
          template <typename, typename> class E,
          template <typename, typename,
                    template <typename, typename> class> class M>
hpx_action_t Evaluator<S, T, E, M>::clear_DAG_ = HPX_ACTION_NULL;

template <typename S, typename T,
          template <typename, typename> class E,
          template <typename, typename,
                    template <typename, typename> class> class M>
hpx_action_t Evaluator<S, T, E, M>::clear_tree_ = HPX_ACTION_NULL;




