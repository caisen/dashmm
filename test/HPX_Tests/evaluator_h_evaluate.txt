ReturnCode evaluate(const Array<source_t> &sources,
                      const Array<target_t> &targets,
                      int refinement_limit, const method_t &method,
                      int n_digits, const std::vector<double> &kernelparams,
                      const distropolicy_t &distro = distropolicy_t { }) {
    // pack the arguments and call the action
    size_t n_params = kernelparams.size();
    size_t total_size = sizeof(EvaluateParams) + n_params * sizeof(double);
    EvaluateParams *args =
        reinterpret_cast<EvaluateParams *>(new char[total_size]); //CONSIDER CHANGING
    args->sources = sources;
    args->targets = targets;
    args->refinement_limit = refinement_limit;
    args->method = method;
    args->n_digits = n_digits;
    args->distro = distro;
    args->rwaddr = HPX_NULL;
    args->alldone = HPX_NULL;
    args->middone = HPX_NULL;
    for (size_t i = 0; i < n_params; ++i) {
      args->kernelparams[i] = kernelparams[i];
    }

    if (HPX_SUCCESS != hpx_run(&evaluate_, nullptr, args, total_size)) {
      return kRuntimeError;
    }

    delete [] args;

    return kSuccess;
  }

static int evaluate_handler(EvaluateParams *parms, size_t total_size) {
    // BEGIN TREE CREATION
    hpx_time_t creation_begin = hpx_time_now();
    RankWise<dualtree_t> global_tree =
        dualtree_t::create(parms->refinement_limit, parms->sources,
                           parms->targets);
    hpx_addr_t partitiondone =
        dualtree_t::partition(global_tree, parms->sources, parms->targets);
    hpx_lco_wait(partitiondone);
    hpx_lco_delete_sync(partitiondone);
    hpx_time_t creation_end = hpx_time_now();
    double creation_deltat = hpx_time_diff_us(creation_begin, creation_end);
    fprintf(stdout, "Evaluation: tree creation %lg [us]\n", creation_deltat);
    // END TREE CREATION

    //auto local_tree = global_tree.here();
    //fprintf(stdout, "UnifGridDistrib:");
    //for (int i = 0; i < hpx_get_num_ranks(); ++i) {
    //  fprintf(stdout, " %d", local_tree->last(i) - local_tree->first(i) + 1);
    //}
    //fprintf(stdout, "\n");

    // Save tree global address in message
    parms->rwaddr = global_tree.data();
    // Save alldone LCO into message
    parms->alldone = hpx_lco_and_new(hpx_get_num_ranks());
    assert(parms->alldone != HPX_NULL);
    // The third is the expansion creation done LCO
    parms->middone = hpx_lco_and_new(hpx_get_num_ranks());
    assert(parms->middone != HPX_NULL);

    // Start the work everywhere
    hpx_bcast_lsync(evaluate_rank_local_, HPX_NULL, parms, total_size);

    // set up dependent call on the broadcast to do evaluate cleanup
    hpx_call_when(parms->alldone, HPX_HERE, evaluate_cleanup_, HPX_NULL,
                  &parms->rwaddr, &parms->alldone, &parms->middone);

    return HPX_SUCCESS;
  }

static int evaluate_rank_local_handler(EvaluateParams *parms,
                                         size_t msg_size) {
    // Generate the table
    RankWise<dualtree_t> global_tree{parms->rwaddr};
    auto tree = global_tree.here();
    double domain_size = tree->domain()->size();
    size_t n_params = (msg_size - sizeof(EvaluateParams)) / sizeof(double);
    std::vector<double> kernel_params(parms->kernelparams,
                                      &parms->kernelparams[n_params]);
    expansion_t::update_table(parms->n_digits, domain_size, kernel_params);
    tree->set_method(parms->method);

    // Get ready to evaluate
    // BEGIN DISTRIBUTE
    hpx_time_t distribute_begin = hpx_time_now();
    DAG *dag = tree->create_DAG();
    parms->distro.compute_distribution(*dag);
    //if (hpx_get_my_rank() == 0) {
    //  dag->printedges(hpx_get_num_ranks());
    //}
    hpx_time_t distribute_end = hpx_time_now();
    double distribute_deltat = hpx_time_diff_us(distribute_begin,
                                                distribute_end);
    //fprintf(stdout, "Evaluate: DAG creation and distribution: %lg [us]\n",
    //        distribute_deltat);
    // END DISTRIBUTE

    // BEGIN ALLOCATE
    hpx_time_t allocate_begin = hpx_time_now();
    tree->create_expansions_from_DAG(parms->rwaddr);

    // NOTE: the previous has to finish for the following. So the previous
    // is a synchronous operation. The next three, however, are not. They all
    // get their work going when they come to it and then they return.
    hpx_lco_and_set(parms->middone, HPX_NULL);
    hpx_lco_wait(parms->middone);
    hpx_time_t allocate_end = hpx_time_now();
    double allocate_deltat = hpx_time_diff_us(allocate_begin, allocate_end);
    //fprintf(stdout, "Evaluate: LCO allocation: %lg [us]\n", allocate_deltat);
    // END ALLOCATE


    // BEGIN EVALUATE
#ifdef DASHMM_INSTRUMENTATION
    libhpx_inst_phase_begin();
    // This is repeated, because the previous call is an atomic operation with
    // a relaxed memory model. That means the first of these only sometimes
    // will emit an event. In (simple and likely incomplete) testing, two
    // is sufficient to always emit at least one.
    EVENT_TRACE_DASHMM_ZEROREF();
    EVENT_TRACE_DASHMM_ZEROREF();
#endif

    hpx_time_t evaluate_begin = hpx_time_now();
    tree->start_DAG_evaluation(global_tree, dag);
    hpx_addr_t heredone = tree->setup_termination_detection(dag);
    hpx_lco_wait(heredone);
    hpx_time_t evaluate_end = hpx_time_now();
    double evaluate_deltat = hpx_time_diff_us(evaluate_begin, evaluate_end);
    //fprintf(stdout, "Evaluate: DAG evaluation: %lg [us]\n", evaluate_deltat);

#ifdef DASHMM_INSTRUMENTATION
    libhpx_inst_phase_end();
#endif
    // END EVALUATE

    fprintf(stdout, "Evaluate: %d - C/D %lg - A %lg - E %lg\n",
            hpx_get_my_rank(),
            distribute_deltat, allocate_deltat, evaluate_deltat);

    // Delete some local stuff
    hpx_lco_delete_sync(heredone);
    tree->destroy_DAG_LCOs(*dag);
    delete dag;

    // Mark that we have finished the rank-local work
    hpx_lco_and_set(parms->alldone, HPX_NULL);

    return HPX_SUCCESS;
  }

static int evaluate_cleanup_handler(hpx_addr_t rwaddr, hpx_addr_t alldone,
                                      hpx_addr_t middone) {
    hpx_lco_delete_sync(alldone);
    hpx_lco_delete_sync(middone);

    // clean up tree and table
    RankWise<dualtree_t> global_tree{rwaddr};
    dualtree_t::destroy(global_tree);

    // Exit from this HPX epoch
    hpx_exit(0, nullptr);
  }
